<?php

namespace Flavorly\InertiaFlash\Notification;

use Flavorly\InertiaFlash\Notification\Concerns\HasContentBlocks;
use Flavorly\InertiaFlash\Notification\Concerns\HasIcon;
use Flavorly\InertiaFlash\Notification\Concerns\HasNotificationActions;
use Flavorly\InertiaFlash\Notification\Concerns\HasNotificationDataLevel;
use Flavorly\InertiaFlash\Notification\Concerns\HasNotificationDataType;
use Flavorly\InertiaFlash\Notification\Concerns\HasNotificationDataViaChannel;
use Flavorly\InertiaFlash\Notification\Concerns\HasNotificationDispatcher;
use Flavorly\InertiaFlash\Notification\Concerns\HasReadableNotifications;
use Flavorly\InertiaFlash\Notification\Concerns\TransformsIntoLaravelNotification;
use Flavorly\InertiaFlash\Notification\Data\NotificationReadableData;
use Flavorly\InertiaFlash\Notification\Data\NotificationTimestampsData;
use Flavorly\InertiaFlash\Notification\Enums\NotificationLevelEnum;
use Flavorly\InertiaFlash\Notification\Enums\NotificationTypeEnum;
use Illuminate\Notifications\DatabaseNotification;
use Illuminate\Notifications\Notification;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
use Spatie\LaravelData\Data;

class FlashNotification extends Data
{
    use HasContentBlocks;
    use HasIcon;
    use HasNotificationActions;
    use HasNotificationDataLevel;
    use HasNotificationDataType;
    use HasNotificationDataViaChannel;
    use HasNotificationDispatcher;
    use HasReadableNotifications;
    use TransformsIntoLaravelNotification;

    /**
     * A unique ID, if its a persistent notification this should be the ID of the notification on the database
     * otherwise is a uuid generated by the body ( message )
     */
    public int|string $id;

    /**
     * The message to be displayed, required
     */
    public string $message;

    /**
     * Default value to true, if false the notification will not be shown
     */
    public bool $shown = true;

    /**
     * Optional Title for the Notification
     */
    public ?string $title = null;

    /**
     * If we should allow raw HTML on the message to be passed in
     *
     * Default is false
     */
    public bool $allows_unsafe_html = false;

    /**
     * A optional timeout for the notification to be closed
     */
    public ?int $timeout = null;

    /**
     * Stores the timestamps for the notification
     */
    public NotificationTimestampsData $timestamps;

    /**
     * Just a blind constructor, we should be able to compose via fluent
     * So no need to pass any arguments
     */
    public function __construct()
    {
        // But here we need to ensure the defaults
        $this->ensureDefaults();
        $this->actions = collect();
        $this->contentBlocks = collect();
        $this->id = 'n-'.Str::uuid();
        $this->readable = new NotificationReadableData();
        $this->notifiable = null;
    }

    /**
     * Ensures the user defaults are set
     */
    protected function ensureDefaults(): void
    {
        // @phpstan-ignore-next-line
        $this->via(config('inertia-flash.notifications.defaults.via', []));
        // @phpstan-ignore-next-line
        $this->level(config('inertia-flash.notifications.defaults.level', NotificationLevelEnum::Info));
        // @phpstan-ignore-next-line
        $this->type(config('inertia-flash.notifications.defaults.type', NotificationTypeEnum::Flash));
    }

    /**
     * The unique ID of the notification
     *
     * @return $this
     */
    public function id(int|string $id): static
    {
        $this->id = $id;

        // Generate the URL once a new ID is set
        $this->ensureReadableURLIsGenerated();

        return $this;
    }

    /**
     * Sets a message & title for the notification
     */
    public function message(string $message, ?string $title = null): static
    {
        $this->message = $message;
        $this->title = $title ?? $this->title;

        return $this;
    }

    /**
     * Sets the title for the notification
     */
    public function title(?string $title = null): static
    {
        $this->title = $title;

        return $this;
    }

    /**
     * Returns the notification as a json
     */
    public function __toString(): string
    {
        $encode = json_encode($this->toArray());
        if ($encode === false) {
            return '';
        }

        return $encode;
    }

    /**
     * Attempts to create a Notification from the Database Record
     *
     * @param DatabaseNotification $notification
     * @return static
     */
    public static function fromModel(DatabaseNotification $notification):static
    {
        $data = static::from($notification->data ?? []);
        if($notification->id !== null) {
            $data->id($notification->id);
        }
        $data->to($notification->notifiable);
        return $data;
    }

    /**
     * Attempts to create a Notification from the Database Records
     *
     * @param mixed|Collection<int,DatabaseNotification> $notifications
     * @return Collection<int,static>
     */
    public static function fromModelCollection(mixed $notifications): Collection
    {
        // @phpstan-ignore-next-line
        return collect($notifications)->map(fn (DatabaseNotification $notification) => static::fromModel($notification));
    }
}
